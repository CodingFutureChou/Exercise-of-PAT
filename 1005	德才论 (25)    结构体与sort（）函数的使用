这题思路大致清晰，按照 rank（等级） sum（总分） d（德分） num(学号）的次序进行排序，
本来是手写了一个冒泡排序（话说我写的冒泡都是i:0->n-1  j:i+1->n，怎么肥事！）严重超时，其他排序法一下有没有头绪。
借鉴了一下sort()的多评定标准的写法：
bool cmp(stu a,stu b){
	if(a.rank!=b.rank) return a.rank<b.rank;
	else if(a.sum!=b.sum) return a.sum>b.sum;
	else if(a.d!=b.d) return a.d>b.d;
	else return a.num<b.num;
}
算是解决这个问题的关键了。


对比一下两个结果的时间如下：

①sort():
        测评结果
        时间	得分	结果	题目	语言	用时(ms)	内存(KB)
        2018-05-07	5	
        答案正确
        德才论 (25)	C++	59	2404
        测试点
        测试点	结果	用时(ms)	内存(KB)
        1	答案正确	55	2148
        2	答案正确	59	2280
        3	答案正确	58	2276
        4	答案正确	59	2404
        5	答案正确	52	2152
        6	答案正确	54	2400
        7	答案正确	53	2400

②冒泡排序：
        测评结果
        时间	得分	结果	题目	语言	用时(ms)	内存(KB)
        2018-05-07	0	
        运行超时
        德才论 (25)	C++	1001	832
        测试点
        测试点	结果	用时(ms)	内存(KB)
        1	答案正确	491	612
        2	运行超时	0	0
        3	答案正确	902	760
        4	运行超时	0	0
        5	答案正确	472	748
        6	答案正确	709	668
        7	答案正确	917	832











//输入描述:
//输入第1行给出3个正整数，分别为：N（<=105），即考生总数；L（>=60），为录取最低分数线，即德分和才分均不低于L的考生才有资格
//被考虑录取；H（<100），为优先录取线——德分和才分均不低于此线的被定义为“才德全尽”，此类考生按德才总分从高到低排序；才分不到
//但德分到线的一类考生属于“德胜才”，也按总分排序，但排在第一类考生之后；德才分均低于H，但是德分不低于才分的考生属于“才德兼
//亡”但尚有“德胜才”者，按总分排序，但排在第二类考生之后；其他达到最低线L的考生也按总分排序，但排在第三类考生之后。
//随后N行，每行给出一位考生的信息，包括：准考证号、德分、才分，其中准考证号为8位整数，德才分为区间[0, 100]内的整数。数字间以空格分隔。
//
//输出描述:
//输出第1行首先给出达到最低分数线的考生人数M，随后M行，每行按照输入格式输出一位考生的信息，考生按输入中说明的规则从高到低排序。当某类考生中有多人
//
//总分相同时，按其德分降序排列；若德分也并列，则按准考证号的升序输出。
//
//输入例子:
//14 60 80
//
//10000001 64 90
//
//10000002 90 60
//
//10000011 85 80
//
//10000003 85 80
//
//10000004 80 85
//
//10000005 82 77
//
//10000006 83 76
//
//10000007 90 78
//
//10000008 75 79
//
//10000009 59 90
//
//10000010 88 45
//
//10000012 80 100
//
//10000013 90 99
//
//10000014 66 60
//
//输出例子:
//12
//
//10000013 90 99
//
//10000012 80 100
//
//10000003 85 80
//
//10000011 85 80
//
//10000004 80 85
//
//10000007 90 78
//
//10000006 83 76
//
//10000005 82 77
//
//10000002 90 60
//
//10000014 66 60
//
//10000008 75 79
//
//10000001 64 90






#include<cstdio>
#include <algorithm>
using namespace std;
	
struct stu{
	int num;
	int d;
	int c;
	int sum;
	int rank;	
};

bool cmp(stu a,stu b){
	if(a.rank!=b.rank) return a.rank<b.rank;
	else if(a.sum!=b.sum) return a.sum>b.sum;
	else if(a.d!=b.d) return a.d>b.d;
	else return a.num<b.num;
}

int main(){
	stu S[100000];
	int N,L,H;
	scanf("%d %d %d",&N,&L,&H);
	int M=0;
	for(int i=0;i<N;i++){
		stu tmp;
		scanf("%d %d %d",&tmp.num, &tmp.d, &tmp.c);
		tmp.sum=tmp.d+tmp.c;
		if(tmp.d>=L&&tmp.c>=L){
			if(tmp.d>=H&&tmp.c>=H) tmp.rank=1;
			else if(tmp.d>=H) tmp.rank=2;
			else if(tmp.d>=tmp.c) tmp.rank=3;
			else tmp.rank=4;
			S[M]=tmp;
			M++;
		}
	}
	
	printf("%d",M);
	
	sort(S,S+M,cmp);
//	for(int i=0;i<M-1;i++)
//		for(int j=i+1;j<M;j++)
//			if(     (S[i].d+S[i].c) < (S[j].d+S[j].c)    ){
//				stu temp;
//				temp=S[i];
//				S[i]=S[j];
//				S[j]=temp;
//			}
//			else if(     (S[i].d+S[i].c) == (S[j].d+S[j].c)    ){
//				if(S[i].d < S[j].d){
//					stu temp;
//					temp=S[i];
//					S[i]=S[j];
//					S[j]=temp;	
//				}
//				else if(S[i].d == S[j].d){
//					if(S[i].num > S[j].num){
//						stu temp;
//						temp=S[i];
//						S[i]=S[j];
//						S[j]=temp;	
//					}
//				}
//			} 		
	for(int i=1;i<=4;i++){
		for(int j=0;j<M;j++){
			if(S[j].rank==i) printf("\n%d %d %d",S[j].num, S[j].d, S[j].c);
		}
	}
	return 0;
}

